/*7-37 模拟EXCEL排序 (25 分)
Excel可以对一组纪录按任意指定列排序。现请编写程序实现类似功能。

输入格式:
输入的第一行包含两个正整数N(≤10^5) 和C，其中N是纪录的条数，C是指定排序的列号。之后有 N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，保证没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（[0, 100]内的整数）组成，相邻属性用1个空格隔开。

输出格式:
在N行中输出按要求排序后的结果，即：当C=1时，按学号递增排序；当C=2时，按姓名的非递减字典序排序；当C=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。

输入样例:
3 1
000007 James 85
000010 Amy 90
000001 Zoe 60

输出样例:
000001 Zoe 60
000007 James 85
000010 Amy 90*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
typedef pair<string, pair<string, int>> person; //类型名过长时可以typedef一下
//pair yyds~
int main()
{
    int n, s, c;
    string num, name;
    vector<person> info;
    cin >> n >> c;
    for (int i = 0; i < n; ++i)
    {
        cin >> num >> name >> s;
        info.push_back(move(pair(num, pair(name, s)))); //move提高效率
    }
    switch (c)
    {
        case 1:
            sort(info.begin(), info.end(), [](person &a, person &b)
            { return a.first < b.first; });
            break;
        case 2:
            sort(info.begin(), info.end(), [](person &a, person &b)
            { return a.second.first < b.second.first || (a.second.first == b.second.first && a.first < b.first); });
            break;
        case 3:
            sort(info.begin(), info.end(), [](person &a, person &b)
            { return a.second.second < b.second.second || (a.second.second == b.second.second && a.first < b.first); });
            break;
    }
    for (auto &p: info)
        cout << p.first << " " << p.second.first << " " << p.second.second << endl;
}